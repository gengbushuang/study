java内存模型
线程共享
    元空间(MetaSpace)-->1.8以前主要是永久代(PermGen)
        元空间主要是本地内存，永久代是jvm内存
        存储class的对象相关信息，字符串常量池
    堆(Heap)
        对象的实例分配
        GC管理主要区域

线程私有
    程序计数器
        当前线程执行的字节码指令，下一条执行指令，方法计数

    虚拟栈
        java方法执行的内存模型
            栈帧
                局部变量表
                    方法执行的所有变量
                操作栈
                    入栈、出栈、数据交换、数据复制等
                动态链接
                返回地址
    本地方法栈

java垃圾回收

分代回收算法
    新生代
        回收算法
            复制算法
                内存按容量划分成两块内存区域，每次只使用一块区域，当其中一块区域要进行回收式，将此区域存活的对象，复制到另一块区域，再把此区域的对象全部清除。
                解决标记-清除算法带来的碎片化问题，按照顺序分配内存，高效简单。
                但是会浪费一点内存空间。

        新生代内存
            Eden区
            两个Survivor区
            当Eden区的要进行回收的时候，把存活对象放到一个Survivor1区中并且对存活对象进行计数，在进行Eden区回收。
            第二次Eden区要进行回收的时候，把Survivor1区中和Eden区的存活对象放到Survivor2区中并且对存活对象进行计数，在对Eden区和Survivor1区回收。
            如此反复，当存活对象计数到一定阈值就会晋升到老年代，如果对象在Eden区和Survivor区都分配不下也会直接晋升到老年代。




    老年代
        回收算法
            标记-清除算法
                标记--从根对象开始进行扫描，对存活的对象进行标记
                清除--进行对象遍历，对不可达的对象进行清除
                碎片化严重

            标记-整理算法
                标记--从根对象开始进行扫描，对存活的对象进行标记。
                整理--对存活的对象按照顺序向一端移动，对存活对象边界以外的对象直接清除。
                解决碎片化问题，不用设置两块内存复制，

        老年代内存
            比新生代空间大，存放一些长时间存活的对象
            老年代空间不足会触发full gc
            Minor GC晋升到老年代的大小大于老年代的剩余空间会触发full gc
            调用System.gc()也会触发full gc

    jdk1.8以前有永久代
        永久代空间不足会触发full gc


